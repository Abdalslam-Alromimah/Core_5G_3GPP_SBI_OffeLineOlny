/**
 * Nchf_OfflineOnlyCharging
 * OfflineOnlyCharging Service Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.2.0-alpha.1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.6.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/QosFlowsUsageReport.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



QosFlowsUsageReport::QosFlowsUsageReport()
{
    m_QFI = 0;
    m_QFIIsSet = false;
    m_StartTimestamp = utility::datetime();
    m_StartTimestampIsSet = false;
    m_EndTimestamp = utility::datetime();
    m_EndTimestampIsSet = false;
    m_UplinkVolume = 0;
    m_UplinkVolumeIsSet = false;
    m_DownlinkVolume = 0;
    m_DownlinkVolumeIsSet = false;
}

QosFlowsUsageReport::~QosFlowsUsageReport()
{
}

void QosFlowsUsageReport::validate()
{
    // TODO: implement validation
}

web::json::value QosFlowsUsageReport::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_QFIIsSet)
    {
        val[utility::conversions::to_string_t(U("qFI"))] = ModelBase::toJson(m_QFI);
    }
    if(m_StartTimestampIsSet)
    {
        val[utility::conversions::to_string_t(U("startTimestamp"))] = ModelBase::toJson(m_StartTimestamp);
    }
    if(m_EndTimestampIsSet)
    {
        val[utility::conversions::to_string_t(U("endTimestamp"))] = ModelBase::toJson(m_EndTimestamp);
    }
    if(m_UplinkVolumeIsSet)
    {
        val[utility::conversions::to_string_t(U("uplinkVolume"))] = ModelBase::toJson(m_UplinkVolume);
    }
    if(m_DownlinkVolumeIsSet)
    {
        val[utility::conversions::to_string_t(U("downlinkVolume"))] = ModelBase::toJson(m_DownlinkVolume);
    }

    return val;
}

bool QosFlowsUsageReport::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("qFI"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("qFI")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setQFI;
            ok &= ModelBase::fromJson(fieldValue, refVal_setQFI);
            setQFI(refVal_setQFI);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("startTimestamp"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("startTimestamp")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setStartTimestamp;
            ok &= ModelBase::fromJson(fieldValue, refVal_setStartTimestamp);
            setStartTimestamp(refVal_setStartTimestamp);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("endTimestamp"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("endTimestamp")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setEndTimestamp;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEndTimestamp);
            setEndTimestamp(refVal_setEndTimestamp);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("uplinkVolume"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("uplinkVolume")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setUplinkVolume;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUplinkVolume);
            setUplinkVolume(refVal_setUplinkVolume);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("downlinkVolume"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("downlinkVolume")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setDownlinkVolume;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDownlinkVolume);
            setDownlinkVolume(refVal_setDownlinkVolume);
        }
    }
    return ok;
}

void QosFlowsUsageReport::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_QFIIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("qFI")), m_QFI));
    }
    if(m_StartTimestampIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("startTimestamp")), m_StartTimestamp));
    }
    if(m_EndTimestampIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("endTimestamp")), m_EndTimestamp));
    }
    if(m_UplinkVolumeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("uplinkVolume")), m_UplinkVolume));
    }
    if(m_DownlinkVolumeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("downlinkVolume")), m_DownlinkVolume));
    }
}

bool QosFlowsUsageReport::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("qFI"))))
    {
        int32_t refVal_setQFI;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("qFI"))), refVal_setQFI );
        setQFI(refVal_setQFI);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("startTimestamp"))))
    {
        utility::datetime refVal_setStartTimestamp;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("startTimestamp"))), refVal_setStartTimestamp );
        setStartTimestamp(refVal_setStartTimestamp);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("endTimestamp"))))
    {
        utility::datetime refVal_setEndTimestamp;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("endTimestamp"))), refVal_setEndTimestamp );
        setEndTimestamp(refVal_setEndTimestamp);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("uplinkVolume"))))
    {
        int32_t refVal_setUplinkVolume;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("uplinkVolume"))), refVal_setUplinkVolume );
        setUplinkVolume(refVal_setUplinkVolume);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("downlinkVolume"))))
    {
        int32_t refVal_setDownlinkVolume;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("downlinkVolume"))), refVal_setDownlinkVolume );
        setDownlinkVolume(refVal_setDownlinkVolume);
    }
    return ok;
}

int32_t QosFlowsUsageReport::getQFI() const
{
    return m_QFI;
}

void QosFlowsUsageReport::setQFI(int32_t value)
{
    m_QFI = value;
    m_QFIIsSet = true;
}

bool QosFlowsUsageReport::qFIIsSet() const
{
    return m_QFIIsSet;
}

void QosFlowsUsageReport::unsetQFI()
{
    m_QFIIsSet = false;
}
utility::datetime QosFlowsUsageReport::getStartTimestamp() const
{
    return m_StartTimestamp;
}

void QosFlowsUsageReport::setStartTimestamp(const utility::datetime& value)
{
    m_StartTimestamp = value;
    m_StartTimestampIsSet = true;
}

bool QosFlowsUsageReport::startTimestampIsSet() const
{
    return m_StartTimestampIsSet;
}

void QosFlowsUsageReport::unsetStartTimestamp()
{
    m_StartTimestampIsSet = false;
}
utility::datetime QosFlowsUsageReport::getEndTimestamp() const
{
    return m_EndTimestamp;
}

void QosFlowsUsageReport::setEndTimestamp(const utility::datetime& value)
{
    m_EndTimestamp = value;
    m_EndTimestampIsSet = true;
}

bool QosFlowsUsageReport::endTimestampIsSet() const
{
    return m_EndTimestampIsSet;
}

void QosFlowsUsageReport::unsetEndTimestamp()
{
    m_EndTimestampIsSet = false;
}
int32_t QosFlowsUsageReport::getUplinkVolume() const
{
    return m_UplinkVolume;
}

void QosFlowsUsageReport::setUplinkVolume(int32_t value)
{
    m_UplinkVolume = value;
    m_UplinkVolumeIsSet = true;
}

bool QosFlowsUsageReport::uplinkVolumeIsSet() const
{
    return m_UplinkVolumeIsSet;
}

void QosFlowsUsageReport::unsetUplinkVolume()
{
    m_UplinkVolumeIsSet = false;
}
int32_t QosFlowsUsageReport::getDownlinkVolume() const
{
    return m_DownlinkVolume;
}

void QosFlowsUsageReport::setDownlinkVolume(int32_t value)
{
    m_DownlinkVolume = value;
    m_DownlinkVolumeIsSet = true;
}

bool QosFlowsUsageReport::downlinkVolumeIsSet() const
{
    return m_DownlinkVolumeIsSet;
}

void QosFlowsUsageReport::unsetDownlinkVolume()
{
    m_DownlinkVolumeIsSet = false;
}
}
}
}
}



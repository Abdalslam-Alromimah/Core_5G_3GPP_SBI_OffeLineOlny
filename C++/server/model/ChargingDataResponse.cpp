/**
* Nchf_OfflineOnlyCharging
* OfflineOnlyCharging Service Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
*
* The version of the OpenAPI document: 1.2.0-alpha.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "ChargingDataResponse.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

ChargingDataResponse::ChargingDataResponse()
{
    m_InvocationTimeStamp = "";
    m_InvocationSequenceNumber = 0;
    m_InvocationResultIsSet = false;
    m_SessionFailoverIsSet = false;
    m_TriggersIsSet = false;
    m_PDUSessionChargingInformationIsSet = false;
    m_RoamingQBCInformationIsSet = false;
    
}

void ChargingDataResponse::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool ChargingDataResponse::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool ChargingDataResponse::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "ChargingDataResponse" : pathPrefix;

             
    
    /* InvocationSequenceNumber */ {
        const int32_t& value = m_InvocationSequenceNumber;
        const std::string currentValuePath = _pathPrefix + ".invocationSequenceNumber";
                
        
        if (value < 0)
        {
            success = false;
            msg << currentValuePath << ": must be greater than or equal to 0;";
        }
        if (value > 4294967295)
        {
            success = false;
            msg << currentValuePath << ": must be less than or equal to 4294967295;";
        }

    }
                 
    if (triggersIsSet())
    {
        const std::vector<org::openapitools::server::model::Trigger>& value = m_Triggers;
        const std::string currentValuePath = _pathPrefix + ".triggers";
                
        
        if (value.size() < 0)
        {
            success = false;
            msg << currentValuePath << ": must have at least 0 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::Trigger& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".triggers") && success;
 
                i++;
            }
        }

    }
            
    return success;
}

bool ChargingDataResponse::operator==(const ChargingDataResponse& rhs) const
{
    return
    
    
    (getInvocationTimeStamp() == rhs.getInvocationTimeStamp())
     &&
    
    (getInvocationSequenceNumber() == rhs.getInvocationSequenceNumber())
     &&
    
    
    ((!invocationResultIsSet() && !rhs.invocationResultIsSet()) || (invocationResultIsSet() && rhs.invocationResultIsSet() && getInvocationResult() == rhs.getInvocationResult())) &&
    
    
    ((!sessionFailoverIsSet() && !rhs.sessionFailoverIsSet()) || (sessionFailoverIsSet() && rhs.sessionFailoverIsSet() && getSessionFailover() == rhs.getSessionFailover())) &&
    
    
    ((!triggersIsSet() && !rhs.triggersIsSet()) || (triggersIsSet() && rhs.triggersIsSet() && getTriggers() == rhs.getTriggers())) &&
    
    
    ((!pDUSessionChargingInformationIsSet() && !rhs.pDUSessionChargingInformationIsSet()) || (pDUSessionChargingInformationIsSet() && rhs.pDUSessionChargingInformationIsSet() && getPDUSessionChargingInformation() == rhs.getPDUSessionChargingInformation())) &&
    
    
    ((!roamingQBCInformationIsSet() && !rhs.roamingQBCInformationIsSet()) || (roamingQBCInformationIsSet() && rhs.roamingQBCInformationIsSet() && getRoamingQBCInformation() == rhs.getRoamingQBCInformation()))
    
    ;
}

bool ChargingDataResponse::operator!=(const ChargingDataResponse& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const ChargingDataResponse& o)
{
    j = nlohmann::json::object();
    j["invocationTimeStamp"] = o.m_InvocationTimeStamp;
    j["invocationSequenceNumber"] = o.m_InvocationSequenceNumber;
    if(o.invocationResultIsSet())
        j["invocationResult"] = o.m_InvocationResult;
    if(o.sessionFailoverIsSet())
        j["sessionFailover"] = o.m_SessionFailover;
    if(o.triggersIsSet() || !o.m_Triggers.empty())
        j["triggers"] = o.m_Triggers;
    if(o.pDUSessionChargingInformationIsSet())
        j["pDUSessionChargingInformation"] = o.m_PDUSessionChargingInformation;
    if(o.roamingQBCInformationIsSet())
        j["roamingQBCInformation"] = o.m_RoamingQBCInformation;
    
}

void from_json(const nlohmann::json& j, ChargingDataResponse& o)
{
    j.at("invocationTimeStamp").get_to(o.m_InvocationTimeStamp);
    j.at("invocationSequenceNumber").get_to(o.m_InvocationSequenceNumber);
    if(j.find("invocationResult") != j.end())
    {
        j.at("invocationResult").get_to(o.m_InvocationResult);
        o.m_InvocationResultIsSet = true;
    } 
    if(j.find("sessionFailover") != j.end())
    {
        j.at("sessionFailover").get_to(o.m_SessionFailover);
        o.m_SessionFailoverIsSet = true;
    } 
    if(j.find("triggers") != j.end())
    {
        j.at("triggers").get_to(o.m_Triggers);
        o.m_TriggersIsSet = true;
    } 
    if(j.find("pDUSessionChargingInformation") != j.end())
    {
        j.at("pDUSessionChargingInformation").get_to(o.m_PDUSessionChargingInformation);
        o.m_PDUSessionChargingInformationIsSet = true;
    } 
    if(j.find("roamingQBCInformation") != j.end())
    {
        j.at("roamingQBCInformation").get_to(o.m_RoamingQBCInformation);
        o.m_RoamingQBCInformationIsSet = true;
    } 
    
}

std::string ChargingDataResponse::getInvocationTimeStamp() const
{
    return m_InvocationTimeStamp;
}
void ChargingDataResponse::setInvocationTimeStamp(std::string const& value)
{
    m_InvocationTimeStamp = value;
}
int32_t ChargingDataResponse::getInvocationSequenceNumber() const
{
    return m_InvocationSequenceNumber;
}
void ChargingDataResponse::setInvocationSequenceNumber(int32_t const value)
{
    m_InvocationSequenceNumber = value;
}
org::openapitools::server::model::InvocationResult ChargingDataResponse::getInvocationResult() const
{
    return m_InvocationResult;
}
void ChargingDataResponse::setInvocationResult(org::openapitools::server::model::InvocationResult const& value)
{
    m_InvocationResult = value;
    m_InvocationResultIsSet = true;
}
bool ChargingDataResponse::invocationResultIsSet() const
{
    return m_InvocationResultIsSet;
}
void ChargingDataResponse::unsetInvocationResult()
{
    m_InvocationResultIsSet = false;
}
org::openapitools::server::model::SessionFailover ChargingDataResponse::getSessionFailover() const
{
    return m_SessionFailover;
}
void ChargingDataResponse::setSessionFailover(org::openapitools::server::model::SessionFailover const& value)
{
    m_SessionFailover = value;
    m_SessionFailoverIsSet = true;
}
bool ChargingDataResponse::sessionFailoverIsSet() const
{
    return m_SessionFailoverIsSet;
}
void ChargingDataResponse::unsetSessionFailover()
{
    m_SessionFailoverIsSet = false;
}
std::vector<org::openapitools::server::model::Trigger> ChargingDataResponse::getTriggers() const
{
    return m_Triggers;
}
void ChargingDataResponse::setTriggers(std::vector<org::openapitools::server::model::Trigger> const& value)
{
    m_Triggers = value;
    m_TriggersIsSet = true;
}
bool ChargingDataResponse::triggersIsSet() const
{
    return m_TriggersIsSet;
}
void ChargingDataResponse::unsetTriggers()
{
    m_TriggersIsSet = false;
}
org::openapitools::server::model::PDUSessionChargingInformation ChargingDataResponse::getPDUSessionChargingInformation() const
{
    return m_PDUSessionChargingInformation;
}
void ChargingDataResponse::setPDUSessionChargingInformation(org::openapitools::server::model::PDUSessionChargingInformation const& value)
{
    m_PDUSessionChargingInformation = value;
    m_PDUSessionChargingInformationIsSet = true;
}
bool ChargingDataResponse::pDUSessionChargingInformationIsSet() const
{
    return m_PDUSessionChargingInformationIsSet;
}
void ChargingDataResponse::unsetPDUSessionChargingInformation()
{
    m_PDUSessionChargingInformationIsSet = false;
}
org::openapitools::server::model::RoamingQBCInformation ChargingDataResponse::getRoamingQBCInformation() const
{
    return m_RoamingQBCInformation;
}
void ChargingDataResponse::setRoamingQBCInformation(org::openapitools::server::model::RoamingQBCInformation const& value)
{
    m_RoamingQBCInformation = value;
    m_RoamingQBCInformationIsSet = true;
}
bool ChargingDataResponse::roamingQBCInformationIsSet() const
{
    return m_RoamingQBCInformationIsSet;
}
void ChargingDataResponse::unsetRoamingQBCInformation()
{
    m_RoamingQBCInformationIsSet = false;
}


} // namespace org::openapitools::server::model

